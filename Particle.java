/**
* A particle class used to represent a particle in a n body system. This
* particle then experiences gravitational forces, due to the gravitational fields
* of other particleswhich translate the particle to a different position.
*
* @author Tehmoor Hussain
* @version 2.5
**/
import java.lang.Math;
import java.util.*;
import java.io.*;

public class Particle
{
	private PhysicsVector Velocity = new PhysicsVector();
	private PhysicsVector Position = new PhysicsVector();
	private PhysicsVector AccelerationSum = new PhysicsVector();
	private PhysicsVector Momentum = new PhysicsVector();

  private double VirialConstant = 0;
	private double PotentialEnergySum = 0;
	private double KineticEnergy = 0;
	private double ParticleMass = 0;
	private double Time = 0;

	/**
	* This constructor is used to set the velocity and position to the initial
	* ones of each planet in turn. It also allows the class to access the time
	* interval and the mass of the particle it will be using.
	* @param InputTime Time Interval determined in main class.
	* @param GenericMass Mass of particle determined from array in main class.
	* @param InitialPosition Initial position of particle determined from array in
	* main class.
	* @param InitialVelocity Initial position of particle determined from array in
	* main class.
	*/
	public Particle(double InputTime, double GenericMass, PhysicsVector InitialPosition, PhysicsVector InitialVelocity)
	{
		Velocity = new PhysicsVector(InitialVelocity);
		Position = new PhysicsVector(InitialPosition);

		ParticleMass = GenericMass;
		Time = InputTime;
	}

	/**
	* This method is used to move the particle using the euler algorithm once the
	* total acceleration has been calculated. Where x_n+1 is the next position,
	* x_n is the current position, v_n is the current velocity, t is the time
	* interval, v_n+1 is the next velocity and a_n is the current acceleration.
	* x_n+1 = x_n + v_n*t
	* v_n+1 = v_n + a_n*t
	*/
  public void euler()
  {
		Position.increaseBy(PhysicsVector.scale(Time, Velocity));
		Velocity.increaseBy(PhysicsVector.scale(Time, AccelerationSum));
	}

	/**
	* This method is used to move the particle using the euler-cramer algorithm.
	* It is exactly the same as the euler algorithm but instead it updates the
	* velocity then the position.
	*/
	public void eulerCramer()
	{
		Velocity.increaseBy(PhysicsVector.scale(Time, AccelerationSum));
		Position.increaseBy(PhysicsVector.scale(Time, Velocity));
	}

	/**
	* This method is used to sum the individual accelerations from each of the
	* bodies in the system acting on the particle.
	* @param PlanetField Generic Gravitational field from which the acceleration
	* is obtained.
	* @param BodyA A body in the system which is used to calculate acceleration on
	* another body.
	* @param BodyB A body in the system which is used to calculate acceleration
	* on another body.
	*/
	public PhysicsVector calculateAccelerationSum(GravField PlanetField, Particle BodyA, Particle BodyB)
	{
		PhysicsVector Acceleration = PlanetField.calculateAcceleration(BodyA, BodyB);
		AccelerationSum.increaseBy(Acceleration);

		return new PhysicsVector(AccelerationSum);
	}

	/**
	* This method is used reset the total acceleration acting on a body after the
	* iteration in which it has been calculated.
	*/
	public PhysicsVector resetAccelerationSum()
	{
		AccelerationSum.setVector(0, 0, 0);

		return new PhysicsVector(AccelerationSum);
	}

	/**
	* This method is used to get a copy of the position of a particle without
	* declaring position globally.
	*/
	public PhysicsVector getPosition()
	{
		return new PhysicsVector(Position);
	}

	/**
	* This method is used to get a copy of the momentum of a particle without
	* declaring momentum globally. It uses the equation;
	* p = mv
	* where m = mass, p = momentum and v = velocity.
	*/
	public PhysicsVector getMomentum()
	{
		Momentum.setVector(Velocity);
		Momentum.scale(ParticleMass);

		return new PhysicsVector(Momentum);
	}

	/**
	* This method is used to sum the potential energy of the particle due to its
	* position in the field generated by all the other bodies in the system.
	* @param GenericField Generic Gravitational field from which the potetial
	* energy is obtained.
	*/
	public double calculatePotentialEnergySum(GravField GenericField)
	{
		double PotentialEnergy = GenericField.getPotentialEnergy(ParticleMass);
		PotentialEnergySum += PotentialEnergy;

    return PotentialEnergySum;
	}

	/**
	* This method is used to implement the virial theorem which states:
	* 2T - U = 0 where T is the kinetic energy of the particle and U is its total
	* potential energy.
	*/
	public double calculateEnergyConservation()
	{
    KineticEnergy = (0.5)*ParticleMass*Math.pow(Velocity.magnitude(),2);
		VirialConstant = (2*KineticEnergy - PotentialEnergySum);
    //The VirialConstant is just a variable to represent the constant energy
		//remaining after the 2T-U operation has been completed.
		return VirialConstant;
	}

	/**
	* This method is used to get the constant resulting from the virial theorem
	* for a particle without declaring the constant globally.
	*/
	public double getViralConstant()
	{
		return VirialConstant;
	}

	/**
	* This method is used to get a copy of the total acceleration acting on a
	* particle without declaring total acceleration globally.
	*/
	public PhysicsVector getAccelerationSum()
	{
		return new PhysicsVector(AccelerationSum);
	}

	/**
	* This method is used to get a copy of the velocity of a particle without
	* declaring velocity globally.
	*/
	public PhysicsVector getVelocity()
	{
		return new PhysicsVector(Velocity);
	}

	/**
	* This method is used to reset the total potential energy after it has been
	* calculated for a particular particle.
	*/
	public double resetPotentialEnergySum()
	{
		PotentialEnergySum = 0;
		return PotentialEnergySum;
	}

	public void printPosition()
	{
		Position.print();
	}

}
